const id = "postgres-race-condition-and-unique-constraint.md";
						const collection = "post";
						const slug = "postgres-race-condition-and-unique-constraint";
						const body = "\nMi sono trovato davanti ad un problema di race condition su Postgres in un processo che doveva importare migliaia di record in parallelo con il risultato che sul database mi ritrovavo con decine di record duplicati.\n\nLe tecnologie coinvolte sono Python3.11, SQLAlchemy 2.0.36 e Postgres 17.2 ma in questo post ricreeremo la situazione con TSQL e un paio di terminali per non avere troppe dipendenze esterne.\n\nAlla fine del post si può trovare il paragrafo con la query tradotta nella sintassi di SQLAlchemy.\n\n## Iniziamo\n\nAvviamo un postgres usando Docker con un semplice `docker compose up -d`\n\n```yaml\nservices:\n  postgres:\n    image: postgres:17.2\n    ports:\n      - 5432:5432\n    environment:\n      - POSTGRES_DB=people\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=dev\n```\n\ne connettiamoci con una shell\n\n```bash\npsql postgresql://user:dev@localhost/people\n```\n\nCreiamo la tabella per il nostro esperimento\n\n```sql\nCREATE TABLE people (\n    id SERIAL NOT NULL,\n    fiscal_code VARCHAR(16) NOT NULL,\n    first_name VARCHAR(255) NOT NULL\n);\n```\n\nInseriamo un paio di dati\n\n```sql\nBEGIN;\nINSERT INTO people (fiscal_code, first_name) VALUES ('AAA', 'Pippo');\nINSERT INTO people (fiscal_code, first_name) VALUES ('BBB', 'Pluto');\nCOMMIT;\n```\n\nControlliamo la nostra tabella\n\n```sql\nSELECT * FROM people;\n\nid | fiscal_code | first_name\n----+-------------+------------\n  1 | AAA         | Pippo\n  2 | BBB         | Pluto\n(2 rows)\n```\n\n## La nostra query\n\nAdesso usiamo il costrutto INSERT INTO SELECT per inserire un nuovo record senza dover fare prima una query per testare l'esistenza del record e otteniamo che nessuna riga viene inserita poichè esiste già un record identico\n\n```sql\nINSERT INTO people (fiscal_code, first_name)\nSELECT\n'AAA',\n'Pippo'\nWHERE NOT EXISTS (\n        SELECT fiscal_code, first_name\n            FROM people\n            WHERE people.fiscal_code = 'AAA'\n            AND people.first_name = 'Pippo'\n        )\nRETURNING people.id, people.fiscal_code, people.first_name;\n```\n\nInfatti la risposta che otteniamo dopo l'insert è\n\n```sql\nid | fiscal_code | first_name\n----+-------------+------------\n(0 rows)\n\nINSERT 0 0\n```\n\nPuliamo la nostra tabella\n\n```sql\nDELETE FROM people;\n```\n\n## Simuliamo una scrittura concorrenziale\n\nApriamo due nuove shell sul terminale e connettiamoci al database\n\nPer simulare la concorrenza usiamo questo trucco:\n\n| **Step** |                  **Shell di sinistra**                   |                   **Shell di destra**                    |\n| :------: | :------------------------------------------------------: | :------------------------------------------------------: |\n|    1     |                    digitiamo `BEGIN;`                    |                                                          |\n|    2     |                                                          |                    digitiamo `BEGIN;`                    |\n|    3     | [Copiamo ed eseguiamo la nostra query](#la-nostra-query) |                                                          |\n|    4     |                                                          | [Copiamo ed eseguiamo la nostra query](#la-nostra-query) |\n|    5     |                    digitiamo `COMMIT`                    |                                                          |\n|    6     |                                                          |                    digitiamo `COMMIT`                    |\n\nEseguiamo lo step 1 nella shell di sinistra e lo step 2 nella shell di destra\n\nOra eseguiamo lo step 3 nella shell di sinistra e riceveremo sul terminale la risposta `INSERT 0 1` ma la transazione non è ancora commitata quindi sul database noi non abbiamo ancora scritto nessun record.\n\nOra eseguiamo lo step 4 e dato che è postgres a preoccuparsi del lock sul record ed essendo la insert una operazione che esegue il lock prima di effettuare cambiamenti ci aspettiamo che la shell rimanga in attesa che l'altra transazione si chiuda ... e invece eseguendo la query anche la seconda shell ci restituisce `INSERT 0 1`\n\nEseguiamo gli step 5 e 6 per concludere le due transazioni\n\nLa [nostra query](#la-nostra-query) con il suo where non è bloccante quindi ci porta ad un problema di race condition da cui non siamo protetti nel caso di concorrenzialità e ci troviamo con i record duplicati\n\n```sql\nSELECT * FROM people;\n\nid | fiscal_code | first_name\n----+-------------+------------\n  3 | AAA         | Pippo\n  4 | AAA         | Pippo\n(2 rows)\n\n```\n\n## La soluzione\n\nCi viene in aiuto un paragrafo della documentazione di [Postgres](https://www.postgresql.org/docs/current/sql-insert.html) che riporta\n\n> INSERT into tables that lack unique indexes will not be blocked by concurrent activity. Tables with unique indexes might block if concurrent sessions perform actions that lock or modify rows matching the unique index values being inserted; the details are covered in Section 62.5. ON CONFLICT can be used to specify an alternative action to raising a unique constraint or exclusion constraint violation error. (See ON CONFLICT Clause below.)\n\nDobbiamo creare un indice univoco per fare in modo che Postgres ci permetta di proteggerci da scritture concorrenti\n\nPuliamo di nuovo la tabella con\n\n```sql\nDELETE FROM people;\n```\n\ne creiamo l'indice\n\n```sql\nALTER TABLE ONLY people ADD CONSTRAINT uq_people_fiscal_code_first_name UNIQUE (fiscal_code, first_name);\n```\n\nAdesso, ripetendo i passaggi del paragrafo [Simuliamo una scrittura concorrenziale](#simuliamo-una-scrittura-concorrenziale) e otteniamo che nella seconda shell rimarremo in attesa finche dalla prima non effettueremo un rollback\no una commit;\n\nTutto perfetto ma nella seconda shell otteniamo un messaggio di errore\n\n> ERROR: duplicate key value violates unique constraint \"uq_people_fiscal_code_first_name\"\n> DETAIL: Key (fiscal_code, first_name)=(AAA, Pippo) already exists.\n\nPrima puliamo la tabella\n\n```sql\nDELETE from people;\n```\n\nServe una piccola modifica alla nostra query aggiungendo la clausola `ON CONFLICT DO NOTHING` e possiamo riprodurre di nuovo i passaggi del paragrafo [Simuliamo una scrittura concorrenziale](#simuliamo-una-scrittura-concorrenziale)\n\n```sql\nINSERT INTO people (fiscal_code, first_name)\nSELECT\n'AAA',\n'Pippo'\nWHERE NOT EXISTS (\n        SELECT fiscal_code, first_name\n            FROM people\n            WHERE people.fiscal_code = 'AAA'\n            AND people.first_name = 'Pippo'\n        )\nON CONFLICT DO NOTHING\nRETURNING people.id, people.fiscal_code, people.first_name;\n```\n\nControlliamo il nostro risultato\n\n```sql\nSELECT * from people;\n\n id | fiscal_code | first_name\n----+-------------+------------\n  7 | AAA         | Pippo\n(1 row)\n```\n\n## Scenario Bonus\n\nE se avessimo uno dei campi della tabella che fosse nullable?\n\nFacciamo una prova\n\n```sql\nDROP TABLE people;\n\nCREATE TABLE people (\n    id SERIAL NOT null,\n    fiscal_code VARCHAR(16) NOT null,\n    first_name VARCHAR(255) NOT null,\n    birth_date timestamptz NULL\n);\n\nALTER TABLE ONLY people ADD CONSTRAINT uq_people_fiscal_code_first_name_birth_date UNIQUE (fiscal_code, first_name, birth_date);\n\n```\n\nInseriamo due righe\n\n```sql\nINSERT INTO people (fiscal_code, first_name, birth_date) VALUES ('AAA', 'Pippo', NULL);\nINSERT INTO people (fiscal_code, first_name, birth_date) VALUES ('AAA', 'Pippo', NULL);\n```\n\n```sql\nSELECT * FROM people;\n\nid | fiscal_code | first_name | birth_date\n----+-------------+------------+------------\n  1 | AAA         | Pippo      |\n  2 | AAA         | Pippo      |\n(2 rows)\n```\n\nIl nostro unique constraint non si è attivato.\n\nQuesto perchè da Postgres 15 è necessario usare la clausola `NULLS NOT DISTINCT` che permette a Postgres di evitare di trattare i null come chiavi distinte.\n\nApplichiamo le modifiche\n\n```sql\nDELETE FROM people;\n\nALTER TABLE people DROP CONSTRAINT uq_people_fiscal_code_first_name_birth_date;\n\nALTER TABLE ONLY people ADD CONSTRAINT uq_people_fiscal_code_first_name_birth_date UNIQUE NULLS NOT DISTINCT (fiscal_code, first_name, birth_date);\n```\n\nE questa volta un solo record viene inserito mentre il secondo darà errore\n\n```sql\nINSERT INTO people (fiscal_code, first_name, birth_date) VALUES ('AAA', 'Pippo', NULL);\nINSERT INTO people (fiscal_code, first_name, birth_date) VALUES ('AAA', 'Pippo', NULL);\n```\n\n## SQLAlchemy Query\n\n```bash\nvirtualenv .venv\n. .venv/bin/activate\n\npip install sqlalchemy==2.0.36\npip install psycopg2-binary==2.9.10\n```\n\n```python\nfrom sqlalchemy.dialects.postgresql import insert\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.sql.schema import MetaData\nfrom sqlalchemy import UniqueConstraint\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom sqlalchemy.sql.sqltypes import String\n\nsession_provider = create_engine(\n    \"postgresql://user:dev@localhost/people\",\n    future=True\n)\n\nmetadata_obj = MetaData()\n\n\nclass Base(DeclarativeBase):\n    metadata = metadata_obj\n\n\nclass Person(Base):\n    __tablename__ = \"people\"\n    __table_args__ = (UniqueConstraint(\"fiscal_code\", \"first_name\", name=\"uq_people_fiscal_code_first_name\"),)\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n\n    fiscal_code: Mapped[str] = mapped_column(String(16))\n    first_name: Mapped[str] = mapped_column(String(255))\n\n\nwith session_provider.begin() as db_session:\n    record = (\n        insert(Person)\n        .values(\n            fiscal_code='AAA',\n            first_name='Pippo',\n        )\n        .on_conflict_do_nothing(index_elements=[\"fiscal_code\", \"first_name\"])\n        .returning(Person)\n    )\n\n    print(db_session.execute(record).scalar_one_or_none())\n```\n";
						const data = {title:"Postgres: Race Condition, Unique Constraints and Handling Concurrency",description:"Come gestire le ace conditions e gli unique constraints in Postgres, utilizzando ON CONFLICT DO NOTHING per prevenire record duplicati",publishDate:new Date(1733526000000),updatedDate:new Date(1733526000000),draft:false,tags:["postgres","python","race condition"]};
						const _internal = {
							type: 'content',
							filePath: "/media/io/Dati/linux/ophusdev-blog/src/content/post/postgres-race-condition-and-unique-constraint.md",
							rawData: "\ntitle: \"Postgres: Race Condition, Unique Constraints and Handling Concurrency\"\ndescription: \"Come gestire le ace conditions e gli unique constraints in Postgres, utilizzando ON CONFLICT DO NOTHING per prevenire record duplicati\"\npublishDate: \"07 Dec 2024\"\nupdatedDate: 07 Dec 2024\ntags: [postgres, python, race condition]",
						};

export { _internal, body, collection, data, id, slug };
